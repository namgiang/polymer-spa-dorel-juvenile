<link rel="import" href="../../molecules/dorel-category-listing-item.html">
<link rel="import" href="../../utils/managers/dorel-category-filter-manager.html">

<dom-module id="dorel-category-listing">
  <template>
    <style>
      h1, h2, h3, h4 {
        @apply(--theme-header-text-transform);
      }

      dorel-layout-row {
        margin-top: -1.5em;
      }

      .no-products {
        border-radius: var(--theme-border-radius-2);
        background-color: var(--theme-color-monochrome-2);
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-top: 1.5em;
        padding: 3em;
      }
    </style>

    <dorel-category-filter-manager
      id="categoryManager"
      filters="{{ filters }}"></dorel-category-filter-manager>

    <dorel-layout-row align="left">
      <template
        is="dom-repeat"
        items="[[products]]"
        as="product"
        filter="[[_filterProducts(filters.*)]]"
        observe="childProducts"
        rendered-item-count="{{renderedCount}}">

        <dorel-layout-column
          desktop-column-span="4"
          tablet-column-span="6"
          mobile-column-span="12">
          <dorel-category-listing-item
            colors-data="[[product.child_products]]"
            link-url="[[product.url]]"
            product-name="[[product.name.value]]"
            filters="[[filters]]"></dorel-category-listing-item>
        </dorel-layout-column>
      </template>

      <dorel-loader
        loading="[[retrievingProducts]]"></dorel-loader>

      <template
        is="dom-if"
        if="[[checkIfProductsAreEmpty(renderedCount, retrievingProducts)]]">
        <div class="no-products">0 [[localize('Results')]]</div>
      </template>
    </dorel-layout-row>
  </template>

  <script>
    class DorelCategoryListing extends Polymer.mixinBehaviors([DorelMultilingualBehavior], Polymer.Element) {

      static get is() { return 'dorel-category-listing'; }

      static get properties() {
        return {
          /**
           * the data coming from magento which is delegated by the parent
           */
          productsData: {
            type: Array,
            observer: '_setProducts'
          },

          /**
           * Object that is passed by the parent containing a type and an order. These will be used to sort the products
           */
          sort: {
            type: Object
          },

          /**
           * Boolean that is passed by the parent will be used by observer, and by dorel-loader component
           */
          retrievingProducts: {
            type: Boolean,
            value: false
          },

          /**
           * Array of the sorted products that will be used by the parent
           */
          products: {
            type: Array
          },

          /**
           * Array of the active filters. Will be used by the dom-repeat
           */
          filters: {
            type: Array
          },

          /**
           * generated by the dom-repeat, shows the
           */
          renderedCount: {
            type: Number,
            notify: true
          }
        }
      }

      /**
       * will set the products with correct sorting
       *
       * @param {array} complete products list
       * @param {boolean} indicator if the application is retrieving products
       */
      _setProducts(newProductsData, oldProductsData) {
        if (!newProductsData.length || this.get('retrievingProducts')) {
          this.set('products', []);
          return;
        }

        const products = this._sortProducts(newProductsData);

        // workaround for deep clone on dom-repeat
        const prodsObj = JSON.parse(JSON.stringify(products));

        this.set('products', prodsObj);
      }

      /**
       * defines the type of sorting and sorts the product items if needed
       *
       * @param {array} the product items to sort
       * @returns {array} sorted products
       */
      _sortProducts(items) {
        if (this.get('retrievingProducts') || !items.length) {
          return [];
        }

        const type = this.get('sort.type');

        if (type && (type === 'date' || type === 'none' || type.includes('standard'))) {
          this.set('sort.type', 'created_at');
        }

        return this._sortString(items, this.get('sort'));
      }

      /**
       * helper to do the heavy lifting on sorting the items if value is String/Number
       *
       * @param {array}
       * @param {object} sorting will will contain `type` and `order`. `type` will select the property to sort on. For example: "name". `order` will determine if it is ordered ascending descending.
       */
      _sortString(items, sort) {
        return items.sort((a, b) => {
          if (!a[sort.type] || !a[sort.type].value || !b[sort.type] || !b[sort.type].value) {
            return 0;
          }

          // if the sort type created_at is set and they are not yet converted to a Date in milliseconds
          if (sort.type === 'created_at') {
            if (typeof a[sort.type].value === 'string') {
              a[sort.type].value = (new Date(a[sort.type].value)).getTime();
            }
            if (typeof b[sort.type].value === 'string') {
              b[sort.type].value = (new Date(b[sort.type].value)).getTime();
            }
          }

          // if a and b are not of the same value
          if (!(typeof a[sort.type].value === 'string' && typeof b[sort.type].value === 'string')
            && !(typeof a[sort.type].value === 'number' && typeof b[sort.type].value === 'number')) {
            return 0;
          }

          // when we are dealing with strings convert to uppercase
          a = typeof a[sort.type].value === 'string' ? a[sort.type].value.toUpperCase() : a[sort.type].value;
          b = typeof b[sort.type].value === 'string' ? b[sort.type].value.toUpperCase() : b[sort.type].value;

          if (a < b) {
            return sort.order === 'asc' ? -1 : 1;
          } else if (a > b) {
            return sort.order === 'asc' ? 1 : -1;
          }

          // names must be equal
          return 0;
        });
      }

      /**
       * filter dom-repeat of products on the fly and determines to show products by currently active filters
       *
       * @param {object} currently active filters
       * @returns Boolean if true show the product
       */
      _filterProducts(filters) {
        return (product) => {
          // if no filters are applied return true
          if (!filters || !filters.base || !filters.base.length) {
            return true;
          }

          // if there is no product return false
          if (!product) {
            return false;
          }

          // returns a Boolean - if true it will show the product
          return this.$.categoryManager.shouldShowProduct(product, filters);
        };
      }

      /**
       * conditional check to see if there are products shown or not
       *
       * @param {number} number of products rendered
       * @param {boolean} current state of retrieval of products
       * @returns Boolean
       */
      checkIfProductsAreEmpty(renderedCount, retrievingProducts) {
        return Boolean(
          renderedCount !== 'undefined'
          && renderedCount === 0
          && retrievingProducts === false
        );
      }
    }

    customElements.define(DorelCategoryListing.is, DorelCategoryListing);
  </script>
</dom-module>
